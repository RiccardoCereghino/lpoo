\chapter{OCaml}
OCaml deriva da \textbf{ML}, è un linguaggio multi-paradigma con un approccio
puramente funzionale, è staticamente tipato con inferenza di tipo:
\begin{itemize}
  \item gli errori di tipo sono rilevati staticamente;
  \item i tipi possono essere omessi nei programmi.
\end{itemize}

\begin{lstlisting}[language=Caml, caption={Sintassi}]
Exp ::= ID | NUM | Exp Exp | 'fun' Pat+ '->' Exp | UOP Exp | Exp BOP Exp | '(' Exp ')'
Pat ::= ID // pattern semplificato
\end{lstlisting}

\paragraph{Commenti:}
\begin{itemize}
  \item \textbf{ID} rappresenta gli identificatori di variabile $[a-zA-Z\_]
    [\backslash w']*$;
  \item \textbf{NUM} rappresenta i numeri naturali:
    \[
      0[bB][01][01\_]*|0[oO][0-7][0-7\_]*|0[xX][0-9a-fA-F][0-9a-fA-F\_]*|\backslash d[\backslash d\_]*
    \];
  \item \textbf{UOP} rappresenta operatori aritmetici unari $[+-]$;
  \item \textbf{BOP} rappresenta operatori aritmetici binari $[+-*\backslash]|mod$;
  \item \textbf{Pat} rappresenta i patterns, per semplicità si possono
    associare agli identificatori.
\end{itemize}

\section{Funzioni ed applicazioni}
\begin{itemize}
  \item esempi di funzioni anonime:
    \begin{lstlisting}[language=Caml, caption={Esempio di funzioni anonime}]
    fun x -> x+1 (* funzione di incremento *)
    fun x y -> x+y (* funzione di addizione *)
    \end{lstlisting}
  \item applicazione di funzioni:
    \begin{lstlisting}[language=Caml, caption={Esempio di applicazione di funzioni}]
    (fun x -> x+1) 3 (* il risultato sara 4 *)
    \end{lstlisting}
\end{itemize}

Inoltre prendendo in esempio:
\begin{lstlisting}[language=Caml, caption={Esempio di applicazioni}]
  exp1 exp2
\end{lstlisting}
\begin{itemize}
  \item l'evaluazione di \textbf{exp1} si aspetta come valore di ritorno una
    funzione $f$;
  \item l'evaluazione di \textbf{exp2} si aspetta come valore di ritorno un
    argomento valido $a$;
  \item l'evaluazione di \textbf{exp1 exp2} ritorna $f(a)$ ($f$ applicato ad
    $a$).
\end{itemize}

\section{Regole di precedenza ed associatività}
\begin{itemize}
  \item Si usano le regole standard per le espressioni aritmetiche;
  \item l'applicazione è associativa a sinistra:
    \begin{lstlisting}[language=Caml, caption={Esempio di associatività}]
    (fun x y -> x+y) 3 4 (* equivale a ((fun x y -> x+y) 3) 4 *)
    \end{lstlisting}
  \item l'applicazione ha precedenza maggiore rispetto gli operatori binari:
    \begin{lstlisting}[language=Caml, caption={Esempio di precedenza}]
    (fun x -> x*2) 1+2 (* equivale a ((fun x -> x*2) 1) +2 *)
    1+(fun x -> x*2) 1+2 (* equivale a 1+((fun x -> x*2) 1) +2 *)
    \end{lstlisting}
  \item le funzioni anonime hanno piorità più bassa rispetto le applicazioni
    e gli operatori binari:
    \begin{lstlisting}[language=Caml, caption={Esempio di precedenza}]
    fun x -> x*2 (* equivale a fun x -> x*2) *)
    fun f a -> f a (* equivale a fun f a -> (f a) *)
    \end{lstlisting}
  \item i casi limite:
    \begin{lstlisting}[language=Caml, caption={Casi limite di precedenza}]
    f + 3 (* addizione *)
    f (+3) (* applicazione *)
    f - 3 (* sottrazione *)
    f (-3) (* applicazione *)
    + f 3 (* equivale a +(f 3) *)
    - f 3 (* equivale a -(f 3) *)
    \end{lstlisting}
\end{itemize}

\section{Una sessione REPL (Read Eval Print Loop)}
\begin{lstlisting}[language=Caml, caption={I tipi possono essere inferiti dall'interprete}]
# 42;;
- : int = 42
# fun x->x*2;;
- : int -> int = <fun>
# (fun x->x+1) 2;;
- : int = 3
\end{lstlisting}

\section{Sintassi}
\begin{lstlisting}[language=Caml, caption={Grammatica BNF}]
Type ::= 'int' | Type '->' Type
\end{lstlisting}

\subsection{Terminologia}
\begin{itemize}
  \item \textbf{int} è il tipo primitivo degli interi;
  \item \textbf{int} -> \textbf{int} è un tipo composito;
  \item \textbf{->} è un tipo \textit{costruttore}, usato per costruire tipi
    compositi da tipi più semplici;
  \item i tipi costruiti con il costruttore freccia (->) sono chiamati \emph{
    arrow types} o \emph{tipi di funzione}.
\end{itemize}

\paragraph{Significato del tipo freccia}
$t_1 -> t_2$ identifica il tipo di funzioni da $t_1$ a $t_2$ che:
\begin{itemize}
  \item piò essere applicazo ad un singolo argomento di tipo $t_1$;
  \item ritorna sempre un valore di tipo $t_2$.
\end{itemize}

\subparagraph{Osservazioni:}
\begin{itemize}
  \item il costruttore di tipo freccia è associativo a destra.
    \begin{lstlisting}[language=Caml, caption={Associatività a destra dell'operatore freccia}]
    int->int->int = int->(int->int)
    \end{lstlisting}
  \item un tipo costruttore costruisce sempre un tipo diverso rispetto a quello
    dei propri componenti:
    \[
      t_1 \text{->} t_2 \neq t_1 \qquad t_1 \text{->} t_2 \neq t_2
    \]
  \item due tipi freccia sono uguali se sono costruiti dallo stesso tipo di
    componenti:
    \[
      t_1 \text{->} t_2 = t_3 \text{->} t_4 \text{ se e solo se } t_1 = t_3 \cap t_2 = t_4
    \]
  \item dai punti prima deduciamo:
    \begin{lstlisting}[language=Caml, escapeinside={(*}{*)}]
    int->int->int (*$\neq$*) int->(int->int)
    \end{lstlisting}
\end{itemize}

\subsection{Funzioni di alto ordine}
\[
  \textbf{fun } pat_1 pat_2 \dots pat_n \text{->} exp
\]
è un abbreviazione di:
\[
  \textbf{fun } pat_1 \text{->}\textbf{fun }pat_2 \text{->}\dots \textbf{fun }pat_n \text{->} exp
\]
\section{Tuple}
\begin{lstlisting}[language=Caml, escapeinside={(*}{*)}, caption={Nuove
produzioni per Exp e Pat}]
Exp ::= '(' ')' | Exp ',' Exp
Pat ::= '(' ')' | '(' Pat (',' Pat)* ')'
\end{lstlisting}

\begin{lstlisting}[language=Caml, escapeinside={(*}{*)}, caption={Nuova
produzione per Type}]
Type ::= 'unit' | Type '*' Type
\end{lstlisting}

\subsection{Precedenza ed associatività}
\begin{itemize}
  \item l'operatore \emph{tuple} ha precedenza più bassa rispetto gli altri
    operatori;
  \item l'operatore \emph{tuple} non è associativo nè a destra nè a sinistra;
  \item il costruttore $*$ ha precedenza maggiore del costruttore $->$;
  \item il costruttore $*$ non è associativo nè a destra nè a sinistra.
\end{itemize}

\begin{lstlisting}[language=Caml, escapeinside={(*}{*)}, caption={Esempi
di tuple}]
# ()
- : unit = ()

# 1,2,3
- : int * int * int = (1,2,3)

# (1,2),3
- : (int * int) * int = ((1,2),3)

# 1,(2,3)
- : int * (int * int) = (1,(2,3))

# fun() -> 3
- : unit -> int = <fun>

# fun ((x,y),z)->x*y*z
- : (int * int) * int -> int = <fun>

#fun (x. (y,z))->x*y*z
- : int * (int * int) -> int 0 <fun>
\end{lstlisting}

\section{Funzioni curry}
\begin{theorem}
  Una funzione curry (da \emph{Haskell Curry}), è una funzione di alto
  ordine con un singolo argomento che ritorna una catena di funzioni con
  un singolo argomento.

  Una funzione non curry è una funzione con argomenti multipli.
\end{theorem}

Una funzione curry può essere trasformata in una funzione non curry e
viceversa.

\begin{lstlisting}[language=Caml, escapeinside={(£}{£)}, caption={Esempi
di funzioni curry}]
(* addizione di due interi *)
fun x y -> x+y;; (* versione curry int->int->int *)
fun (x y) -> x+y;; (* versione non curry int->int->int *)
(* moltiplicazione di tre interi *)
fun x y z -> x*y*z;; (* versione curry int->int->int->int *)
fun (x y z) -> x*y*z;; (* versione non curry int->int->int->int *)
\end{lstlisting}

\subsection{Applicazione parziale}
Le funzioni curry permettono l'applicazione parziale, ovvero gli argomenti
possono essere passati uno alla volta.

Le funzioni non curry non permettono un applicazione parziale, tutti gli
argomenti devono essere passai.
\begin{lstlisting}[language=Caml, escapeinside={(£}{£)}, caption={Esempi
di applicazione parziale di funzioni curry}]
let curried_add x y=x+y;;
let uncurried_add(x,y)=x+y;;
(* computa 1+2 con la versione non curry *)
uncarried_add(1,2);;
(* computa 1+2 con l'applicazione parziale *)
let inc=curried_add 1;; (* passa l'argomento 1 e salva il risultato *)
inc 2;; (* passa l'argomento 2 e computa il risultato finale *)
\end{lstlisting}

L'applicazione parziale permette la specializzazione di funzioni: da una
funzione generica è possibile generarne di più specifiche senza
duplicazione di codice, quindi il riutilizzo e la mantenibilità sono
favoriti.

\section{Valori booleani}
Per $BOOL=false|true$.
\begin{lstlisting}[language=Caml, escapeinside={(£}{£)}, caption={Sintassi}]
Exp ::= BOOL | 'not' Exp | Exp '&&' Exp | Exp '||' Exp
Type ::= 'bool'
\end{lstlisting}

\subsection{Regole sintattiche standard}
\begin{itemize}
  \item $\&\&$ e $||$ sono associativi a sinistra;
  \item \textbf{not} ha precedenza maggiore di $\&\&$;
  \item $\&\&$ ha precedenza maggiore di $||$.
\end{itemize}

\subsection{Semantica statica}
\begin{itemize}
  \item \textbf{false} e \textbf{true} sono di tipo \emph{bool};
  \item \textbf{not} $e$ è di tipo \emph{bool} se e solo se $e$ è di tipo
    \emph{bool};
  \item il tipo di \textbf{not} $e$ non è corretto se $e$ non è di tipo
    \emph{bool} oppure se il tipo di $e$ non è corretto;
  \item $e_1\&\&e_2$ e $e_1||e_2$ sono di tipo \emph{bool} se e solo se $e_1$
    ed $e_2$ sono di tipo \emph{bool};
  \item il tipo di \textbf{not} $e_1\&\&e_2$ e $e_1||e_2$ non è corretto se
    $e_1$ o $e_2$ non sono di tipo \emph{bool} oppure se il tipo di $e_1$ o
    $e_2$ non è corretto.
\end{itemize}


Inoltre:
\begin{itemize}
  \item gli operatori $\&\&$ e $||$ sono risolti sinistra a destra;
  \item se $e_1$ ritorna \emph{false} allora $e_1\&\&e_2$ ritorna
    \emph{false}, altrimenti ritorna il valore di $e_2$;
  \item se $e_1$ ritorna \emph{true} allora $e_1||e_2$ ritorna \emph{true},
    altrimenti ritorna il valore di $e_2$.
\end{itemize}

\subsection{Espressioni condizionali}
le operazioni condizionali hanno precedenza minore di tutte le altre
operazioni.

\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Espressioni condizionali
  }]
Exp ::= 'if' Exp 'then Exp 'else' Exp
\end{lstlisting}

\section{Variabili globali}
\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Grammatica delle variabili globali
  }
]
Dec ::= 'let' Def (' and' Def)*
    | 'let' 'rec' FunDef (' and' FunDef)*
Def ::= Pat '=' Exp | FunDef
FunDef ::= ID Pat* '=' Exp
\end{lstlisting}

\paragraph{Esempio di variabili globali e funzioni curry}
Consideriamo i seguenti due esempi.
\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Addizione di quadrati
  }
]
let rec sumsquare n = (* sumsquare si usa anche con associativo a destra*)
  if n<=0 then 0 else n*n+sumsquare(n-1);;
\end{lstlisting}

\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Addizione di cubi
  }
]
let rec sumcube n = (* sumcube si usa anche con associativo a destra*)
  if n<=0 then 0 else n*n+sumcube(n-1);;
\end{lstlisting}


Si nota che sono quasi identici, quindi si può usare una funzione curry.

\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Soluzione con funzione curry
  }
]
let rec gen_sum f n = (* (int -> int) -> int -> int *)
if n<=0 then 0 else f n+gen_su, f (n-1);;

let der_sumsquare = gen_sum (fun x->x*x);; (* int -> int *)
let der_sumcube = gen_sum (fun x->x*x*x);; (* int -> int *)
\end{lstlisting}

Notiamo che $gen\_sum$ può essere specializzato dato che è funzione curry
ed il primo argomento è $f$ piuttosto che $n$.

\section{Dichiarazione di variabili locali}
\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Sintassi delle variabili locali
  }
]
Dec ::= 'let' Def (' and' Def)* 'in' Exp
    | 'let' 'rec' FunDef (' and' FunDef)* 'in' Exp
Def ::= Pat '=' Exp | FunDef
FunDef ::= ID Pat* '=' Exp
\end{lstlisting}

\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Esempio di variabili locali
  }
]
let f x=x+1 and v=41 in f v;; (* f e v possono essere usati solo qui *)
- : int = 42
let x=1 in let x=x*2 in x*x (* dichiarazioni annidate *)
- : int = 4
\end{lstlisting}

Da notare che le dichiarazioni annidate sovrascrivono le dichiarazioni con
lo stessi $ID$.

\subsection{Scopo delle dichiarazioni statiche}
\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Esempio di dicharazione statica
  }
]
let v=40;;

let f x = x*v;; (* v riferisce alla dichiarazione precedente *)

f 3;; (* ritorna 120 *)

let v=4;; (* dichiarazione di v sovrascritta *)

f 3;; (* ritorna 120 *)
\end{lstlisting}

\begin{lstlisting}[
  language=Caml,
  escapeinside={(£}{£)},
  caption={
    Miglioramento dell'esempio della somma di quadrati e cubi
  }
]
let gen_sum f = (* (int ->) -> int -> int *)
    let rec aux n = if n<=0 then 0 else f n+aux (n-1) (* int -> int )
    in aux;;
\end{lstlisting}

Non dobbiamo passare l'argomento $f$ alla funzione ricorsiva $aux$.

\clearpage
\section{Liste}
\begin{lstlisting}[
    language=Caml,
    escapeinside={(£}{£)},
    caption={
      Sintassi delle liste
    }
  ]
  Exp ::= '[' ']' | Exp '::'Exp
\end{lstlisting}

\begin{itemize}
  \item la lista vuota è rappresentata da $[]$;
  \item $hd::ts$ è la lista con la testa ($hd$) e la coda ($tl$);
  \item $[]\neq t_1::t_2$ e $t_1\neq t_1::t_2$ e $t_2\neq t_1::t_2$;
  \item $t_1::t_2=t_1^\prime::t_2^\prime$ se e solo se $t_1=t_1^\prime$ e $t_2
    =t_2^\prime$;
  \item $[e_1;e_2;\dots;e_n]$ è l'abbreviazione per $e_1::e_2::\dots::e_n$.
\end{itemize}

\paragraph{Regole sintattiche}
\begin{itemize}
  \item Associatività a destra;
  \item minore precedenza degli operatori unari e binari con notazione
    infissa;
  \item maggiore precedenza del costruttore di tupla;

    ...

    ...
    .
\end{itemize}

\subsection{Tipi di costruttori per le liste}
Le liste devono essere omogenee, tutti gli elementi devono essere dello stesso
tipo:
\begin{itemize}
  \item 
\end{itemize}
